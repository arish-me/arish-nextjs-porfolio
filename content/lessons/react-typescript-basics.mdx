---
title: TypeScript with React
chapterSlug: react-typescript
duration: 18
order: 1
---

## TypeScript with React

TypeScript adds static types to React, catching errors before runtime and improving developer experience.

## Setup

```bash
# New Vite project with TypeScript
npm create vite@latest my-app -- --template react-ts

# Add TypeScript to existing project
npm install -D typescript @types/react @types/react-dom
```

## Typing Components

### Function Components

```tsx
// Inline props type
function Greeting({ name }: { name: string }) {
  return <h1>Hello, {name}!</h1>
}

// Interface for props
interface ButtonProps {
  label: string
  onClick: () => void
  disabled?: boolean  // Optional prop
}

function Button({ label, onClick, disabled = false }: ButtonProps) {
  return (
    <button onClick={onClick} disabled={disabled}>
      {label}
    </button>
  )
}

// Type alias (alternative to interface)
type CardProps = {
  title: string
  children: React.ReactNode
}

function Card({ title, children }: CardProps) {
  return (
    <div className="card">
      <h2>{title}</h2>
      {children}
    </div>
  )
}
```

### Children Types

```tsx
// ReactNode - most flexible
interface LayoutProps {
  children: React.ReactNode  // Accepts anything renderable
}

// ReactElement - only JSX elements
interface WrapperProps {
  children: React.ReactElement
}

// String only
interface TitleProps {
  children: string
}

// Function children (render props)
interface MouseProps {
  children: (position: { x: number; y: number }) => React.ReactNode
}
```

## Typing Hooks

### useState

```tsx
// Type is inferred
const [count, setCount] = useState(0)  // number
const [name, setName] = useState('')   // string

// Explicit type for complex types
const [user, setUser] = useState<User | null>(null)
const [items, setItems] = useState<Item[]>([])

// Union type for specific values
type Status = 'idle' | 'loading' | 'success' | 'error'
const [status, setStatus] = useState<Status>('idle')
```

### useRef

```tsx
// DOM element ref
const inputRef = useRef<HTMLInputElement>(null)
const divRef = useRef<HTMLDivElement>(null)
const buttonRef = useRef<HTMLButtonElement>(null)

// Usage
const focus = () => {
  inputRef.current?.focus()
}

// Mutable ref (for values)
const countRef = useRef<number>(0)
countRef.current = 5  // No error
```

### useReducer

```tsx
type State = {
  count: number
  step: number
}

type Action = 
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'setStep'; payload: number }
  | { type: 'reset' }

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'increment':
      return { ...state, count: state.count + state.step }
    case 'decrement':
      return { ...state, count: state.count - state.step }
    case 'setStep':
      return { ...state, step: action.payload }
    case 'reset':
      return { count: 0, step: 1 }
  }
}

const [state, dispatch] = useReducer(reducer, { count: 0, step: 1 })
```

### useContext

```tsx
interface AuthContextType {
  user: User | null
  login: (email: string, password: string) => Promise<void>
  logout: () => void
}

const AuthContext = createContext<AuthContextType | null>(null)

function useAuth(): AuthContextType {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}
```

## Typing Events

```tsx
function Form() {
  // Input change event
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    console.log(e.target.value)
  }
  
  // Form submit event
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
  }
  
  // Click event
  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    console.log(e.clientX, e.clientY)
  }
  
  // Keyboard event
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      console.log('Enter pressed')
    }
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input onChange={handleChange} onKeyDown={handleKeyDown} />
      <button onClick={handleClick}>Submit</button>
    </form>
  )
}
```

## Generic Components

```tsx
// Generic list component
interface ListProps<T> {
  items: T[]
  renderItem: (item: T) => React.ReactNode
  keyExtractor: (item: T) => string
}

function List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {
  return (
    <ul>
      {items.map(item => (
        <li key={keyExtractor(item)}>{renderItem(item)}</li>
      ))}
    </ul>
  )
}

// Usage
interface User {
  id: string
  name: string
}

<List<User>
  items={users}
  renderItem={(user) => <span>{user.name}</span>}
  keyExtractor={(user) => user.id}
/>
```

## Extending HTML Elements

```tsx
// Extend button props
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary'
  size?: 'small' | 'medium' | 'large'
}

function Button({ variant = 'primary', size = 'medium', ...props }: ButtonProps) {
  return (
    <button 
      className={`btn btn-${variant} btn-${size}`}
      {...props}
    />
  )
}

// Extend input props
interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string
  error?: string
}

function Input({ label, error, ...props }: InputProps) {
  return (
    <div>
      {label && <label>{label}</label>}
      <input {...props} />
      {error && <span className="error">{error}</span>}
    </div>
  )
}
```

## Type Utilities

```tsx
// Pick - select specific props
type ButtonLabelProps = Pick<ButtonProps, 'label' | 'disabled'>

// Omit - exclude specific props
type ButtonWithoutLabel = Omit<ButtonProps, 'label'>

// Partial - make all props optional
type OptionalButtonProps = Partial<ButtonProps>

// Required - make all props required
type RequiredButtonProps = Required<ButtonProps>

// Extract return type of component
type Props = React.ComponentProps<typeof Button>
```

TypeScript makes React development safer and more productive!

