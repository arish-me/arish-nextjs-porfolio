---
title: Testing Custom Hooks
chapterSlug: react-testing
duration: 12
order: 2
---

## Testing Custom Hooks

Custom hooks need special handling since they can only be called inside React components.

## Setup

```bash
npm install -D @testing-library/react
```

## renderHook Utility

```jsx
import { renderHook, act } from '@testing-library/react'

// Custom hook
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue)
  
  const increment = () => setCount(c => c + 1)
  const decrement = () => setCount(c => c - 1)
  const reset = () => setCount(initialValue)
  
  return { count, increment, decrement, reset }
}

// Test
describe('useCounter', () => {
  it('initializes with default value', () => {
    const { result } = renderHook(() => useCounter())
    
    expect(result.current.count).toBe(0)
  })
  
  it('initializes with provided value', () => {
    const { result } = renderHook(() => useCounter(10))
    
    expect(result.current.count).toBe(10)
  })
  
  it('increments count', () => {
    const { result } = renderHook(() => useCounter())
    
    act(() => {
      result.current.increment()
    })
    
    expect(result.current.count).toBe(1)
  })
  
  it('decrements count', () => {
    const { result } = renderHook(() => useCounter(5))
    
    act(() => {
      result.current.decrement()
    })
    
    expect(result.current.count).toBe(4)
  })
  
  it('resets to initial value', () => {
    const { result } = renderHook(() => useCounter(10))
    
    act(() => {
      result.current.increment()
      result.current.increment()
    })
    
    expect(result.current.count).toBe(12)
    
    act(() => {
      result.current.reset()
    })
    
    expect(result.current.count).toBe(10)
  })
})
```

## Testing Async Hooks

```jsx
// Custom hook
function useFetch(url) {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(url)
        const json = await response.json()
        setData(json)
      } catch (err) {
        setError(err.message)
      } finally {
        setLoading(false)
      }
    }
    
    fetchData()
  }, [url])
  
  return { data, loading, error }
}

// Test
describe('useFetch', () => {
  beforeEach(() => {
    global.fetch = vi.fn()
  })
  
  it('fetches data successfully', async () => {
    const mockData = { name: 'John' }
    global.fetch.mockResolvedValue({
      json: () => Promise.resolve(mockData)
    })
    
    const { result } = renderHook(() => useFetch('/api/user'))
    
    // Initially loading
    expect(result.current.loading).toBe(true)
    expect(result.current.data).toBe(null)
    
    // Wait for fetch to complete
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
    })
    
    expect(result.current.data).toEqual(mockData)
    expect(result.current.error).toBe(null)
  })
  
  it('handles fetch error', async () => {
    global.fetch.mockRejectedValue(new Error('Network error'))
    
    const { result } = renderHook(() => useFetch('/api/user'))
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
    })
    
    expect(result.current.data).toBe(null)
    expect(result.current.error).toBe('Network error')
  })
  
  it('refetches when URL changes', async () => {
    const mockData1 = { id: 1 }
    const mockData2 = { id: 2 }
    
    global.fetch
      .mockResolvedValueOnce({ json: () => Promise.resolve(mockData1) })
      .mockResolvedValueOnce({ json: () => Promise.resolve(mockData2) })
    
    const { result, rerender } = renderHook(
      ({ url }) => useFetch(url),
      { initialProps: { url: '/api/user/1' } }
    )
    
    await waitFor(() => {
      expect(result.current.data).toEqual(mockData1)
    })
    
    // Change URL
    rerender({ url: '/api/user/2' })
    
    await waitFor(() => {
      expect(result.current.data).toEqual(mockData2)
    })
  })
})
```

## Testing Hooks with Context

```jsx
// Custom hook that uses context
function useAuth() {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}

// Test
describe('useAuth', () => {
  const wrapper = ({ children }) => (
    <AuthProvider>
      {children}
    </AuthProvider>
  )
  
  it('returns auth context', () => {
    const { result } = renderHook(() => useAuth(), { wrapper })
    
    expect(result.current.user).toBe(null)
    expect(typeof result.current.login).toBe('function')
    expect(typeof result.current.logout).toBe('function')
  })
  
  it('throws without provider', () => {
    expect(() => {
      renderHook(() => useAuth())
    }).toThrow('useAuth must be used within AuthProvider')
  })
  
  it('updates user on login', async () => {
    const { result } = renderHook(() => useAuth(), { wrapper })
    
    await act(async () => {
      await result.current.login('test@example.com', 'password')
    })
    
    expect(result.current.user).toEqual({
      email: 'test@example.com'
    })
  })
})
```

## Testing useEffect Cleanup

```jsx
function useEventListener(event, handler) {
  useEffect(() => {
    window.addEventListener(event, handler)
    return () => window.removeEventListener(event, handler)
  }, [event, handler])
}

describe('useEventListener', () => {
  it('adds event listener', () => {
    const addSpy = vi.spyOn(window, 'addEventListener')
    const handler = vi.fn()
    
    renderHook(() => useEventListener('click', handler))
    
    expect(addSpy).toHaveBeenCalledWith('click', handler)
  })
  
  it('removes event listener on unmount', () => {
    const removeSpy = vi.spyOn(window, 'removeEventListener')
    const handler = vi.fn()
    
    const { unmount } = renderHook(() => useEventListener('click', handler))
    
    unmount()
    
    expect(removeSpy).toHaveBeenCalledWith('click', handler)
  })
})
```

## Testing useDebounce

```jsx
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value)
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)
    
    return () => clearTimeout(timer)
  }, [value, delay])
  
  return debouncedValue
}

describe('useDebounce', () => {
  beforeEach(() => {
    vi.useFakeTimers()
  })
  
  afterEach(() => {
    vi.useRealTimers()
  })
  
  it('returns initial value immediately', () => {
    const { result } = renderHook(() => useDebounce('initial', 500))
    expect(result.current).toBe('initial')
  })
  
  it('debounces value changes', () => {
    const { result, rerender } = renderHook(
      ({ value }) => useDebounce(value, 500),
      { initialProps: { value: 'initial' } }
    )
    
    rerender({ value: 'updated' })
    
    // Still initial before timeout
    expect(result.current).toBe('initial')
    
    // Fast forward
    act(() => {
      vi.advanceTimersByTime(500)
    })
    
    expect(result.current).toBe('updated')
  })
})
```

Testing hooks ensures your reusable logic works correctly!

