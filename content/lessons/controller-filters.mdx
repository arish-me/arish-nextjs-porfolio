---
title: Controller Filters and Callbacks
chapterSlug: controllers-and-actions
duration: 10
order: 1
---

## Controller Filters

Filters are methods that run before, after, or around controller actions. They help you share common logic across actions and keep your controllers DRY.

## Before Action

Run code before an action executes:

```ruby
class ArticlesController < ApplicationController
  before_action :authenticate_user!
  before_action :set_article, only: [:show, :edit, :update, :destroy]
  before_action :authorize_author, only: [:edit, :update, :destroy]
  
  def show
    # @article is already set
  end
  
  def edit
    # @article is set and user is authorized
  end
  
  def update
    if @article.update(article_params)
      redirect_to @article
    else
      render :edit
    end
  end
  
  private
  
  def set_article
    @article = Article.find(params[:id])
  end
  
  def authorize_author
    unless @article.user == current_user
      redirect_to articles_path, alert: "Not authorized"
    end
  end
end
```

### Filter Options

```ruby
class ArticlesController < ApplicationController
  # Only for specific actions
  before_action :authenticate_user!, only: [:new, :create, :edit, :update, :destroy]
  
  # Except for specific actions
  before_action :authenticate_user!, except: [:index, :show]
  
  # With conditions
  before_action :check_premium, if: :premium_content?
  before_action :log_request, unless: :admin_user?
  
  # With lambda
  before_action :track_view, if: -> { request.format.html? }
  
  private
  
  def premium_content?
    @article&.premium?
  end
  
  def admin_user?
    current_user&.admin?
  end
end
```

## After Action

Run code after an action executes:

```ruby
class ArticlesController < ApplicationController
  after_action :track_view, only: [:show]
  after_action :log_response, if: -> { Rails.env.development? }
  
  def show
    @article = Article.find(params[:id])
  end
  
  private
  
  def track_view
    @article.increment!(:views_count)
  end
  
  def log_response
    Rails.logger.info "Response: #{response.status}"
  end
end
```

## Around Action

Wrap an action with before and after logic:

```ruby
class ArticlesController < ApplicationController
  around_action :with_timing
  around_action :catch_exceptions
  
  def index
    @articles = Article.all
  end
  
  private
  
  def with_timing
    start = Time.current
    yield  # Execute the action
    duration = Time.current - start
    Rails.logger.info "Action took #{duration}s"
  end
  
  def catch_exceptions
    yield
  rescue StandardError => e
    Rails.logger.error "Error: #{e.message}"
    redirect_to root_path, alert: "Something went wrong"
  end
end
```

## Skip Filters

Override parent controller filters:

```ruby
class ApplicationController < ActionController::Base
  before_action :authenticate_user!
end

class PublicController < ApplicationController
  skip_before_action :authenticate_user!
end

class ArticlesController < ApplicationController
  skip_before_action :authenticate_user!, only: [:index, :show]
end
```

## Prepend and Append

Control the order of filters:

```ruby
class ApplicationController < ActionController::Base
  before_action :set_locale
  before_action :authenticate_user!
end

class ArticlesController < ApplicationController
  # Runs BEFORE parent filters
  prepend_before_action :check_maintenance_mode
  
  # Runs AFTER parent filters (default behavior)
  before_action :set_article
  # Same as: append_before_action :set_article
end
```

## Common Filter Patterns

### Authentication

```ruby
class ApplicationController < ActionController::Base
  before_action :authenticate_user!
  
  private
  
  def authenticate_user!
    unless current_user
      store_location
      redirect_to login_path, alert: "Please log in"
    end
  end
  
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end
  
  def store_location
    session[:return_to] = request.fullpath if request.get?
  end
end
```

### Authorization

```ruby
class ArticlesController < ApplicationController
  before_action :set_article, only: [:show, :edit, :update, :destroy]
  before_action :require_author, only: [:edit, :update, :destroy]
  
  private
  
  def require_author
    unless @article.user == current_user || current_user.admin?
      redirect_to @article, alert: "You can't edit this article"
    end
  end
end
```

### Setting Instance Variables

```ruby
class ArticlesController < ApplicationController
  before_action :set_article, only: [:show, :edit, :update, :destroy]
  before_action :set_categories, only: [:new, :edit, :create, :update]
  
  private
  
  def set_article
    @article = Article.find(params[:id])
  rescue ActiveRecord::RecordNotFound
    redirect_to articles_path, alert: "Article not found"
  end
  
  def set_categories
    @categories = Category.all
  end
end
```

### Request Format Handling

```ruby
class ApiController < ApplicationController
  before_action :set_default_format
  before_action :authenticate_api_key!
  
  private
  
  def set_default_format
    request.format = :json unless params[:format]
  end
  
  def authenticate_api_key!
    api_key = request.headers["X-API-Key"]
    head :unauthorized unless valid_api_key?(api_key)
  end
end
```

### Tracking and Analytics

```ruby
class ApplicationController < ActionController::Base
  after_action :track_action
  
  private
  
  def track_action
    Analytics.track(
      user_id: current_user&.id,
      action: "#{controller_name}##{action_name}",
      path: request.path,
      referrer: request.referrer
    )
  end
end
```

### Caching Headers

```ruby
class ArticlesController < ApplicationController
  before_action :set_cache_headers, only: [:show]
  
  private
  
  def set_cache_headers
    response.headers["Cache-Control"] = "public, max-age=3600"
  end
end
```

Filters keep your controller actions focused on their core responsibilities!

