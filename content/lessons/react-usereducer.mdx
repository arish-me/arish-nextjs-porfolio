---
title: useReducer Hook
chapterSlug: react-state-management
duration: 15
order: 2
---

## useReducer Hook

`useReducer` is an alternative to `useState` for complex state logic. It's like having a mini Redux inside your component.

## Basic Syntax

```jsx
import { useReducer } from 'react'

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 }
    case 'decrement':
      return { count: state.count - 1 }
    default:
      return state
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 })
  
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
    </div>
  )
}
```

## useState vs useReducer

| useState | useReducer |
|----------|-----------|
| Simple state | Complex state logic |
| Few state updates | Many state updates |
| Independent state values | Related state values |
| No strict pattern | Predictable reducer pattern |

```jsx
// useState - good for simple state
const [count, setCount] = useState(0)
const [name, setName] = useState('')

// useReducer - good for complex state
const [state, dispatch] = useReducer(reducer, {
  count: 0,
  step: 1,
  history: []
})
```

## Reducer Pattern

```jsx
// Action types (optional but recommended)
const ACTIONS = {
  INCREMENT: 'INCREMENT',
  DECREMENT: 'DECREMENT',
  SET_STEP: 'SET_STEP',
  RESET: 'RESET'
}

// Initial state
const initialState = {
  count: 0,
  step: 1
}

// Reducer function - must be pure!
function counterReducer(state, action) {
  switch (action.type) {
    case ACTIONS.INCREMENT:
      return { ...state, count: state.count + state.step }
    
    case ACTIONS.DECREMENT:
      return { ...state, count: state.count - state.step }
    
    case ACTIONS.SET_STEP:
      return { ...state, step: action.payload }
    
    case ACTIONS.RESET:
      return initialState
    
    default:
      throw new Error(`Unknown action: ${action.type}`)
  }
}

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, initialState)
  
  return (
    <div>
      <p>Count: {state.count}</p>
      <p>Step: {state.step}</p>
      
      <button onClick={() => dispatch({ type: ACTIONS.INCREMENT })}>
        +{state.step}
      </button>
      <button onClick={() => dispatch({ type: ACTIONS.DECREMENT })}>
        -{state.step}
      </button>
      
      <input
        type="number"
        value={state.step}
        onChange={(e) => dispatch({ 
          type: ACTIONS.SET_STEP, 
          payload: parseInt(e.target.value) || 1 
        })}
      />
      
      <button onClick={() => dispatch({ type: ACTIONS.RESET })}>
        Reset
      </button>
    </div>
  )
}
```

## Todo App with useReducer

```jsx
const ACTIONS = {
  ADD_TODO: 'ADD_TODO',
  TOGGLE_TODO: 'TOGGLE_TODO',
  DELETE_TODO: 'DELETE_TODO',
  EDIT_TODO: 'EDIT_TODO',
  CLEAR_COMPLETED: 'CLEAR_COMPLETED',
  SET_FILTER: 'SET_FILTER'
}

const initialState = {
  todos: [],
  filter: 'all' // 'all', 'active', 'completed'
}

function todoReducer(state, action) {
  switch (action.type) {
    case ACTIONS.ADD_TODO:
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: Date.now(),
            text: action.payload,
            completed: false
          }
        ]
      }
    
    case ACTIONS.TOGGLE_TODO:
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      }
    
    case ACTIONS.DELETE_TODO:
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload)
      }
    
    case ACTIONS.EDIT_TODO:
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, text: action.payload.text }
            : todo
        )
      }
    
    case ACTIONS.CLEAR_COMPLETED:
      return {
        ...state,
        todos: state.todos.filter(todo => !todo.completed)
      }
    
    case ACTIONS.SET_FILTER:
      return {
        ...state,
        filter: action.payload
      }
    
    default:
      return state
  }
}

function TodoApp() {
  const [state, dispatch] = useReducer(todoReducer, initialState)
  const [input, setInput] = useState('')
  
  const filteredTodos = state.todos.filter(todo => {
    if (state.filter === 'active') return !todo.completed
    if (state.filter === 'completed') return todo.completed
    return true
  })
  
  const handleSubmit = (e) => {
    e.preventDefault()
    if (input.trim()) {
      dispatch({ type: ACTIONS.ADD_TODO, payload: input })
      setInput('')
    }
  }
  
  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Add todo..."
        />
        <button type="submit">Add</button>
      </form>
      
      <div>
        {['all', 'active', 'completed'].map(filter => (
          <button
            key={filter}
            onClick={() => dispatch({ type: ACTIONS.SET_FILTER, payload: filter })}
            className={state.filter === filter ? 'active' : ''}
          >
            {filter}
          </button>
        ))}
      </div>
      
      <ul>
        {filteredTodos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => dispatch({ type: ACTIONS.TOGGLE_TODO, payload: todo.id })}
            />
            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
            <button onClick={() => dispatch({ type: ACTIONS.DELETE_TODO, payload: todo.id })}>
              Delete
            </button>
          </li>
        ))}
      </ul>
      
      <button onClick={() => dispatch({ type: ACTIONS.CLEAR_COMPLETED })}>
        Clear Completed
      </button>
    </div>
  )
}
```

## Lazy Initialization

For expensive initial state:

```jsx
function init(initialCount) {
  // Expensive computation or localStorage read
  return { count: initialCount }
}

function Counter({ initialCount }) {
  const [state, dispatch] = useReducer(reducer, initialCount, init)
  // init function only runs once
}
```

## Action Creators

Helper functions to create actions:

```jsx
// Action creators
const addTodo = (text) => ({ type: ACTIONS.ADD_TODO, payload: text })
const toggleTodo = (id) => ({ type: ACTIONS.TOGGLE_TODO, payload: id })
const deleteTodo = (id) => ({ type: ACTIONS.DELETE_TODO, payload: id })

// Usage
dispatch(addTodo('Learn React'))
dispatch(toggleTodo(123))
dispatch(deleteTodo(123))
```

## Combining with Context

```jsx
const TodoContext = createContext()

function TodoProvider({ children }) {
  const [state, dispatch] = useReducer(todoReducer, initialState)
  
  return (
    <TodoContext.Provider value={{ state, dispatch }}>
      {children}
    </TodoContext.Provider>
  )
}

function useTodos() {
  const context = useContext(TodoContext)
  if (!context) {
    throw new Error('useTodos must be used within TodoProvider')
  }
  return context
}
```

useReducer brings predictable state management to React!

