---
title: React Performance Basics
chapterSlug: react-performance
duration: 15
order: 1
---

## React Performance Optimization

Understanding and optimizing React performance is crucial for building fast applications.

## How React Renders

```
State/Props Change → Component Re-renders → Virtual DOM Diff → DOM Updates
```

React re-renders a component when:
1. Its state changes
2. Its props change
3. Its parent re-renders
4. Context it consumes changes

## React.memo

Prevent re-renders when props haven't changed:

```jsx
// Without memo - re-renders on every parent render
function ExpensiveList({ items }) {
  console.log('Rendering list...')
  return items.map(item => <Item key={item.id} item={item} />)
}

// With memo - only re-renders when items change
const ExpensiveList = React.memo(function ExpensiveList({ items }) {
  console.log('Rendering list...')
  return items.map(item => <Item key={item.id} item={item} />)
})
```

### Custom Comparison

```jsx
const MemoizedComponent = React.memo(
  function Component({ user, onClick }) {
    return <div onClick={onClick}>{user.name}</div>
  },
  (prevProps, nextProps) => {
    // Return true if props are equal (skip re-render)
    return prevProps.user.id === nextProps.user.id
  }
)
```

## useMemo for Expensive Calculations

```jsx
function ProductList({ products, filter }) {
  // ❌ Runs on every render
  const filteredProducts = products.filter(p => p.category === filter)
  
  // ✅ Only recalculates when dependencies change
  const filteredProducts = useMemo(() => {
    console.log('Filtering products...')
    return products.filter(p => p.category === filter)
  }, [products, filter])
  
  return (
    <ul>
      {filteredProducts.map(p => <ProductItem key={p.id} product={p} />)}
    </ul>
  )
}
```

## useCallback for Stable Function References

```jsx
function Parent() {
  const [count, setCount] = useState(0)
  
  // ❌ New function on every render
  const handleClick = () => console.log('clicked')
  
  // ✅ Stable reference
  const handleClick = useCallback(() => {
    console.log('clicked')
  }, [])
  
  return <MemoizedChild onClick={handleClick} />
}

// Child only re-renders if onClick reference changes
const MemoizedChild = React.memo(function Child({ onClick }) {
  console.log('Child rendered')
  return <button onClick={onClick}>Click</button>
})
```

## Avoiding Unnecessary Re-renders

### Move State Down

```jsx
// ❌ Bad - entire app re-renders on input change
function App() {
  const [text, setText] = useState('')
  
  return (
    <div>
      <Header />
      <input value={text} onChange={e => setText(e.target.value)} />
      <ExpensiveComponent />
      <Footer />
    </div>
  )
}

// ✅ Good - only SearchBox re-renders
function App() {
  return (
    <div>
      <Header />
      <SearchBox />
      <ExpensiveComponent />
      <Footer />
    </div>
  )
}

function SearchBox() {
  const [text, setText] = useState('')
  return <input value={text} onChange={e => setText(e.target.value)} />
}
```

### Lift Content Up

```jsx
// ❌ Bad - children re-render on color change
function ColorPicker() {
  const [color, setColor] = useState('red')
  
  return (
    <div style={{ backgroundColor: color }}>
      <input value={color} onChange={e => setColor(e.target.value)} />
      <ExpensiveTree /> {/* Re-renders every time! */}
    </div>
  )
}

// ✅ Good - children passed as prop don't re-render
function App() {
  return (
    <ColorPicker>
      <ExpensiveTree />
    </ColorPicker>
  )
}

function ColorPicker({ children }) {
  const [color, setColor] = useState('red')
  
  return (
    <div style={{ backgroundColor: color }}>
      <input value={color} onChange={e => setColor(e.target.value)} />
      {children} {/* Doesn't re-render! */}
    </div>
  )
}
```

## Virtualization for Long Lists

Only render visible items:

```bash
npm install @tanstack/react-virtual
```

```jsx
import { useVirtualizer } from '@tanstack/react-virtual'

function VirtualList({ items }) {
  const parentRef = useRef(null)
  
  const virtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50,
  })
  
  return (
    <div ref={parentRef} style={{ height: '400px', overflow: 'auto' }}>
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          position: 'relative',
        }}
      >
        {virtualizer.getVirtualItems().map(virtualItem => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${virtualItem.size}px`,
              transform: `translateY(${virtualItem.start}px)`,
            }}
          >
            {items[virtualItem.index].name}
          </div>
        ))}
      </div>
    </div>
  )
}
```

## Debouncing User Input

```jsx
function SearchInput() {
  const [query, setQuery] = useState('')
  const [debouncedQuery, setDebouncedQuery] = useState('')
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(query)
    }, 300)
    
    return () => clearTimeout(timer)
  }, [query])
  
  useEffect(() => {
    if (debouncedQuery) {
      performSearch(debouncedQuery)
    }
  }, [debouncedQuery])
  
  return (
    <input
      value={query}
      onChange={e => setQuery(e.target.value)}
      placeholder="Search..."
    />
  )
}
```

## Profiling

Use React DevTools Profiler:

1. Open React DevTools
2. Go to "Profiler" tab
3. Click "Record"
4. Interact with your app
5. Click "Stop"
6. Analyze render times and causes

## Key Performance Tips

1. **Don't optimize prematurely** - Measure first
2. **Use React.memo strategically** - Not everywhere
3. **Keep state local** - Only lift when needed
4. **Virtualize long lists** - 1000+ items
5. **Lazy load components** - Code splitting
6. **Use Web Workers** - Heavy computations

Performance optimization is about making informed decisions!

