---
title: useContext Hook
chapterSlug: react-hooks
duration: 15
order: 3
---

## useContext Hook

The `useContext` hook lets you subscribe to React context and access values from any component without prop drilling.

## The Problem: Prop Drilling

```jsx
// Without context - passing props through many levels
function App() {
  const [theme, setTheme] = useState('dark')
  return <Header theme={theme} setTheme={setTheme} />
}

function Header({ theme, setTheme }) {
  return <Navigation theme={theme} setTheme={setTheme} />
}

function Navigation({ theme, setTheme }) {
  return <ThemeToggle theme={theme} setTheme={setTheme} />
}

function ThemeToggle({ theme, setTheme }) {
  // Finally use the props!
  return <button onClick={() => setTheme(t => t === 'dark' ? 'light' : 'dark')}>{theme}</button>
}
```

## The Solution: Context

### Step 1: Create Context

```jsx
import { createContext } from 'react'

// Create with default value
const ThemeContext = createContext('light')

// Or without default (useful when value is always provided)
const ThemeContext = createContext(null)

export default ThemeContext
```

### Step 2: Provide Context

```jsx
import { useState } from 'react'
import ThemeContext from './ThemeContext'

function App() {
  const [theme, setTheme] = useState('dark')
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <Header />
    </ThemeContext.Provider>
  )
}
```

### Step 3: Consume Context

```jsx
import { useContext } from 'react'
import ThemeContext from './ThemeContext'

function ThemeToggle() {
  const { theme, setTheme } = useContext(ThemeContext)
  
  return (
    <button onClick={() => setTheme(t => t === 'dark' ? 'light' : 'dark')}>
      Current theme: {theme}
    </button>
  )
}
```

## Complete Example: Theme Context

```jsx
// ThemeContext.jsx
import { createContext, useContext, useState } from 'react'

const ThemeContext = createContext(null)

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light')
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light')
  }
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}

export function useTheme() {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider')
  }
  return context
}

// App.jsx
import { ThemeProvider } from './ThemeContext'

function App() {
  return (
    <ThemeProvider>
      <Header />
      <Main />
      <Footer />
    </ThemeProvider>
  )
}

// Any nested component
import { useTheme } from './ThemeContext'

function ThemeToggle() {
  const { theme, toggleTheme } = useTheme()
  
  return (
    <button onClick={toggleTheme}>
      Switch to {theme === 'light' ? 'dark' : 'light'} mode
    </button>
  )
}
```

## Authentication Context

```jsx
// AuthContext.jsx
import { createContext, useContext, useState, useEffect } from 'react'

const AuthContext = createContext(null)

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)
  
  useEffect(() => {
    // Check for existing session
    const checkAuth = async () => {
      try {
        const response = await fetch('/api/auth/me')
        if (response.ok) {
          const userData = await response.json()
          setUser(userData)
        }
      } finally {
        setLoading(false)
      }
    }
    checkAuth()
  }, [])
  
  const login = async (email, password) => {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      body: JSON.stringify({ email, password })
    })
    const userData = await response.json()
    setUser(userData)
    return userData
  }
  
  const logout = async () => {
    await fetch('/api/auth/logout', { method: 'POST' })
    setUser(null)
  }
  
  return (
    <AuthContext.Provider value={{ user, loading, login, logout }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}

// Usage
function Profile() {
  const { user, logout, loading } = useAuth()
  
  if (loading) return <p>Loading...</p>
  if (!user) return <p>Please log in</p>
  
  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <button onClick={logout}>Logout</button>
    </div>
  )
}
```

## Multiple Contexts

```jsx
function App() {
  return (
    <AuthProvider>
      <ThemeProvider>
        <CartProvider>
          <Main />
        </CartProvider>
      </ThemeProvider>
    </AuthProvider>
  )
}

// Component using multiple contexts
function Header() {
  const { user } = useAuth()
  const { theme } = useTheme()
  const { itemCount } = useCart()
  
  return (
    <header className={theme}>
      <span>Welcome, {user?.name}</span>
      <span>Cart: {itemCount} items</span>
    </header>
  )
}
```

## Context with TypeScript

```tsx
import { createContext, useContext, useState, ReactNode } from 'react'

interface User {
  id: string
  name: string
  email: string
}

interface AuthContextType {
  user: User | null
  login: (email: string, password: string) => Promise<void>
  logout: () => void
  loading: boolean
}

const AuthContext = createContext<AuthContextType | null>(null)

interface AuthProviderProps {
  children: ReactNode
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)
  
  const login = async (email: string, password: string) => {
    // login logic
  }
  
  const logout = () => {
    setUser(null)
  }
  
  return (
    <AuthContext.Provider value={{ user, login, logout, loading }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth(): AuthContextType {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}
```

## Optimizing Context

Split contexts to avoid unnecessary re-renders:

```jsx
// ❌ All consumers re-render when any value changes
const AppContext = createContext({
  user: null,
  theme: 'light',
  language: 'en'
})

// ✅ Separate contexts for unrelated values
const UserContext = createContext(null)
const ThemeContext = createContext('light')
const LanguageContext = createContext('en')
```

## Default Values

```jsx
// Default used when no Provider is above
const ThemeContext = createContext({
  theme: 'light',
  toggleTheme: () => {
    console.warn('No ThemeProvider found')
  }
})

// Now components work even without Provider
function ThemedButton() {
  const { theme } = useContext(ThemeContext)
  return <button className={theme}>Click me</button>
}
```

Context is powerful for sharing global state across your app!

